---
title: "BNNNNN_XXXX_NN RNA Analysis"
author: "BiGR Team<BR>bigr@gustaveroussy.fr"
date: "`r format(Sys.time(), '%Y/%m/%d')`"
output:
  html_document: 
    background: black
    fig_height: 10
    fig_width: 15
    highlight: tango  ## Theme for the code chunks
    number_sections: true  ## Adds number to headers (sections)
    theme: flatly  ## CSS theme for the HTML page
    toc: true  ## Adds a table of content
    toc_float:  ## TOC options
      collapsed: true  ## By default, the TOC is folded
    smooth_scroll: true ## Smooth scroll of the HTML page
    self_contained: true ## Includes all plots/images within the HTML
    code_download: true ## Adds a button to download the Rmd
    code_folding: show
    thumbnails: false
    lightbox: true
    fig_caption: false
    gallery: true
    use_bookdown: true
always_allow_html: true ## Allow plain HTML code in the Rmd
---

# Working environment setup

## Variables

```{r setup_var, message = FALSE}

## DIRECTORIES / INPUT FILES

### DIR : root directory (in which the environment can be found)
root_dir <- '/home/job/WORKSPACE/PROJECTS/B25007_ELEL_01_RT156.24_TRICS_RNAseq.FFPE'

### DIR : Main analysis dir (project dir that contains QC subdir)
analysis_dir <- "/home/job/WORKSPACE/PROJECTS/B25007_ELEL_01_RT156.24_TRICS_RNAseq.FFPE/RESULTS/RNAseq.FFPE_20250129154120/"


### INPUT : RDS object generated by the GeoMX_QC_template.Rmd (a DESeq2 object that contains raw expression data, after outlier removal)
input_RDS <- "/home/job/WORKSPACE/PROJECTS/B25007_ELEL_01_RT156.24_TRICS_RNAseq.FFPE/RESULTS/RNAseq.FFPE_20250129154120/QC/Raw_outlier.filtered_55s.RDS"

### INPUT : Optional additional sample annotation (MS XLSX) file path. It has to be synched (same length, same sample names, same order) with the annotations from the DSP output, and first column has to be the same as this output column "SegmentDisplayName". Keep as NULL if no file to provide
# annot_filename <- NULL
annot_filename <- "/home/job/WORKSPACE/PROJECTS/B25007_ELEL_01_RT156.24_TRICS_RNAseq.FFPE/ANNOTATIONS/B25007_ELEL_01_Annotations_20250212_Regressed_for_Liver_type.xlsx"

### Analysis tag name
analysis_name <- 'Exploratory_analysis_Normalized.for.Liver_type'

### ANNOTATION : sample names column
annot_sn <- 'Sample_id'

## OTHER PARAMETERS

### LIST of CATEGORICAL/DISCRETE data types to enlight (by split/coloring) in plots, and assess as covariates. Keys are displayed names, values are annotation table column names
## No special character allowed !!
box_categ <- list(
  'Pathology' = 'Pathology'
  ,
  'Best response' = 'Best_response'
  ,
  'Progression' = 'Progression'
  ,
  'Death status' = 'Death_status'
  ,
  'OS event' = 'OS_event'
  ,
  'Type of sample' = 'Type_of_sample'
  ,
  'Liver type of sample' = 'Liver_type'
  ,
  'Metastatic CT line - 2 classes' = 'Metastatic_CT_line.3'
  ,
  'PFS - 2 classes - 3 monthes' = 'PFS.3_m'
  ,
  'PFS - 2 classes - 12 monthes' = 'PFS.12_m'
  ,
  'PFS - 3 classes (months)' = 'PFS.3.12_m'
  ,
  'prevICI' = 'prevICI'
  ,
  'Visceral metastasis' = 'Visceral_metastasis'
  ,
  'Bone metastasis' = 'Bone_metastasis'
  ,
  'De-novo metastasis' = 'De_novo_metastasis'
  ,
  'Dose (mg)' = 'Dose_mg'
)


### VECTOR of annotation column names to assess as putative CONTINUOUS covariates. (this should be changed to a list in further updates, in sake of homogeneity with box_categ) Default are common ones for GeoMX RNA.
conti_categ <- c(
  'TC.pc'
  ,
  'Age_at_diag_y'
  ,
  'Metastatic_line'
  ,
  'Metastatic_CT_line'
  ,
  'PFS_m'
  ,
  'OS_m'
  ,
  'Reads_by_run'
)

## BASIC PARAMETERS

### Species name (needed for GSEA/ORA/GSVA to transpose symbols to ENTREZ)
species = 'Homo sapiens'
### Number of max different distant colors to generate in the RGB space, for boxplots/PCAs (should cover all possible classes in any of the requested annotation)
ncolors <- 20
### Fixing seed
my_seed <- 1337
### DESeq2 normalization method (only VST supported yet)
norm_method <- 'vst'
### Top variant genes to use for PCA
# topvar <- 200   # For panel > 200 genes
topvar <- 500   # For whole transcriptome
### Significance threshold
adjp.max <- 5E-02
### Minimum absolute log2FoldChange threshold
# lfc.min <- 1
lfc.min <- 0
min_count <- 5L
# min_samples <- 2
min_sample_freq <- .5
## Types of distance to clusterize samples
samples_dist_method <- c(
  'spearman'
  ,
  'manhattan'
  ,
  'euclidean'
)
## Minimum term length to perform GSEA/ORA
enr_min_genes <- 5
dotplot.maxterms <- 50

## GSEA DBs
### MSigDB
msigdb.do.tmp <- c(TRUE, TRUE)
msigdb.collec <- as.data.frame(msigdbr::msigdbr_collections())
msigdb.collec <- msigdb.collec[grep(pattern = '(GO:|REACTOME|WIKIPATHWAYS|KEGG)', x = msigdb.collec$gs_subcat, ignore.case = TRUE, invert = TRUE),]
# msigdb.collec <- msigdb.collec[msigdb.collec$gs_cat == 'H',, drop = FALSE]
msigdb.collec$tag <- paste(msigdb.collec$gs_cat, msigdb.collec$gs_subcat, sep = '.')
msigdb.collec$tag <- sub(pattern = '\\.$', replacement = '', x = msigdb.collec$tag)
msigdb.do <- lapply(msigdb.collec$tag, function(x) { return(msigdb.do.tmp) })
names(msigdb.do) <- msigdb.collec$tag
# msigdb.do <- msigdb.do[-c(grep(pattern = '(GO|WIKI|REACTOME|KEGG)', x = names(msigdb.do)))]
# ### Others
do.do <- c(TRUE, TRUE)
go.do <- c(TRUE, TRUE)
kegg.do <- c(TRUE, TRUE)
wp.do <- c(TRUE, TRUE)
reactome.do <- c(TRUE, TRUE)
mesh.do <- c(FALSE, FALSE)
custom.do <- c(FALSE, FALSE)
# custom_gmt_file <- NULL
custom_gmt_file <- "/home/job/WORKSPACE/PROJECTS/B25007_ELEL_01_RT156.24_TRICS_RNAseq.FFPE/ANNOTATIONS/custom_gmt_entrezid.gmt.gz"
custom_gmt_list <- NULL
custom.do <- c(FALSE, FALSE)

if(!is.null(custom_gmt_file)) {
  custom_gmt_list <- list(Custom = clusterProfiler::read.gmt(gmtfile = custom_gmt_file))
  custom.do <- c(TRUE, TRUE)
}

## TMP (GSEA/ORA deactivated for tests, except for MsigDB:Hallmarks)
msigdb.do <- list(H = c(TRUE, TRUE))
do.do <- c(FALSE, FALSE)
go.do <- c(FALSE, FALSE)
kegg.do <- c(FALSE, FALSE)
wp.do <- c(FALSE, FALSE)
reactome.do <- c(FALSE, FALSE)
mesh.do <- c(FALSE, FALSE)


## Immune Deconvolution
### Common parameters
is_tumor <- TRUE
is_array <- FALSE
### ImmuneDeconv methods
id_methods  <- c(
  'quantiseq'
  ,
  'epic'
  ,
  'cibersort'
  ,
  'mcp_counter'
  ,
  'abis'
  ,
  'estimate'
  # ,
  # 'xcell'
)
### Cibersort
#### Script path
cibersort_binary_path <- '/home/job/WORKSPACE/TOOLS/cibersort/CIBERSORT_v1.06.R'
#### LM22 database
cibersort_lm22_path <- '/home/job/WORKSPACE/TOOLS/cibersort/LM22.txt'
#### Absolute mode
cibersort_absolute <- TRUE

## If data come from the salmon pipeline, use the TPM matrix for immune deconvolution
salmon_pipeline_tpm_file <- NULL
# salmon_pipeline_tpm_file <- '/home/job/WORKSPACE/PROJECTS/B25007_ELEL_01_RT156.24_TRICS_RNAseq.FFPE/DATA/TPM.genes.tsv.gz'


### CiberSortX
# cibersortx_resfile <- NULL
cibersortx_resfile <- '/home/job/WORKSPACE/PROJECTS/B25007_ELEL_01_RT156.24_TRICS_RNAseq.FFPE/RESULTS/RNAseq.FFPE_20250129154120/Exploratory_analysis_Normalized.for.Liver_type_20250211171624/ImmuneDeconv/from.DESeq2/cibersortx_results/CIBERSORTx_Job12_Results.txt'
# cibersortx_absolute <- FALSE
cibersortx_absolute <- TRUE

### EcoTyper
# ecotyper_resfile <- NULL
ecotyper_resfile <- '/home/job/WORKSPACE/PROJECTS/B25007_ELEL_01_RT156.24_TRICS_RNAseq.FFPE/RESULTS/RNAseq.FFPE_20250129154120/Exploratory_analysis_Normalized.for.Liver_type_20250211171624/ImmuneDeconv/from.DESeq2/ecotyper_results/Carcinoma_Ecotypes/Ecotype_Abundance.txt'

## GSVA
### GMT path(s)
gmt_path <- c(
  "~/WORKSPACE/RESOURCES/DATABASE/GMT/Homo_sapiens/BADERLAB/20250104/"
  , 
  "~/WORKSPACE/RESOURCES/DATABASE/GMT/Homo_sapiens/KEGG/20250130/"
  , 
  "~/WORKSPACE/RESOURCES/DATABASE/GMT/Homo_sapiens/MSigDB/v2024.1.Hs/"
  , 
  "/home/job/WORKSPACE/RESOURCES/DATABASE/GMT/Homo_sapiens/PathwayCommons/v14/"
  , 
  "~/WORKSPACE/RESOURCES/DATABASE/GMT/Homo_sapiens/Reactome/v91/"
  , 
  "~/WORKSPACE/RESOURCES/DATABASE/GMT/Homo_sapiens/WikiPathways/20250110/"
  ,
  "/home/job/WORKSPACE/PROJECTS/B25007_ELEL_01_RT156.24_TRICS_RNAseq.FFPE/ANNOTATIONS/"
  )

```


## Setup

### Prepping variables

```{r setup_set, message = FALSE}
## Source outside scripts
source_script <- c('svg_png.R', 'RNA_functions.R', 'NMF_run.R', 'skmeans_run.R', 'ChiFisher.R')
for (ssc in source_script) {
  source(paste(c(root_dir, 'ENV/RNAseqAnalysis/script/R', ssc), collapse = '/'))
}

## Clean annotations colname variables
box_categ <- if(!is.null(box_categ)) lapply(box_categ, function(x) gsub(pattern = "\\W", replacement = '.', x = x))
conti_categ <- if(!is.null(conti_categ)) lapply(conti_categ, function(x) gsub(pattern = "\\W", replacement = '.', x = x))

## Generate a color palette
listcol <- distinct_color_maker(n_colors = ncolors, my_seed = my_seed)

## Early setup (folders)
analysis_name <- paste(c(analysis_name, format(Sys.time(), '%Y%m%d%H%M%S')), collapse = '_')
work_dir <- paste(c(analysis_dir, analysis_name), collapse = '/')
dir.create(work_dir, recursive = TRUE)
# setwd(work_dir)

## Backup original graphical parameters
oripar <- par(no.readonly = TRUE)

```

## Loading data

```{r data_load}

## Load data
de2 <- readRDS(file = input_RDS)

## Load additional annotations (needs to be synched with the current annot_df). WARNING : except for the annot_sn common column name, any column name in the additional table which is already present in the initial one will REPLACE the initial one !
if (!is.null(annot_filename)) {
  ## Load additinal annotation table
  comp_df <- as.data.frame(readxl::read_excel(path =  annot_filename, na = c('', 'na', 'NA')))
  ## Clean colnames
  colnames(comp_df) <- gsub(pattern = "\\W", replacement = '.', x = colnames(comp_df))
  ## Synch it to the metadata
  comp_df <- comp_df[comp_df[[annot_sn]] %in% de2@colData[[annot_sn]],]
  if (nrow(de2@colData) !=  nrow(comp_df)) {
    stop('Initial and additional annotation tables are NOT synched : different number of lines (', nrow(de2@colData), ' vs ', nrow(comp_df), ') !')
  } else if (all(de2@colData[[annot_sn]] != comp_df[[annot_sn]])) {
    stop('Initial and additional annotation tables are NOT synched (different samples order or composition) !')
  } else {
    ## Add new / update columns
    for (newc in colnames(comp_df)[-c(which(colnames(comp_df) == annot_sn))]) de2@colData[[newc]] <- comp_df[[newc]]
  }
}

## Convert box_categ entries to factors
for (bcfac in unname(unlist(box_categ))) de2@colData[[bcfac]] <- as.factor(de2@colData[[bcfac]])

```

# Normalization

Expression is first normalized by computing scaling factors, taking care of batch, then using variance stabilization.

The method used is :

```{r normmethod}
norm_method
```


```{r norm, message=FALSE}
## Computing size factors and dispersion
de2 <- DESeq2::estimateSizeFactors(object = de2)
## Save RAW exp
saveRDS(de2, file = paste0(work_dir, '/DESeq2Obj_Raw.RDS'), compress = 'bzip2')
write.table(x = data.frame(Feature = rownames(SummarizedExperiment::assay(de2)), SummarizedExperiment::assay(de2)), file = gzfile(paste0(work_dir, '/Raw_counts_', ncol(SummarizedExperiment::assay(de2)), 's.tsv.gz')), sep = '\t', quote = FALSE, row.names = FALSE)
## Normalization
if (tolower(norm_method) == 'vst') {
  message('Normalizing using vst ...')
  de2.norm <- DESeq2::vst(object = de2, blind = TRUE, nsub = topvar)
} else if (tolower(norm_method) == 'rlog') {
  message('Normalizing using rlog ...')
  de2.norm <- DESeq2::rlog(object = de2, blind = TRUE)
}
## Save Normalized
saveRDS(de2.norm, file = paste0(work_dir, '/DESeq2Obj_Norm.', tolower(norm_method), '.RDS'), compress = 'bzip2')
write.table(x = data.frame(Feature = rownames(SummarizedExperiment::assay(de2.norm)), SummarizedExperiment::assay(de2.norm)), file = gzfile(paste0(work_dir, '/Normalized.', norm_method, '_counts_', ncol(SummarizedExperiment::assay(de2.norm)), 's.tsv.gz')), sep = '\t', quote = FALSE, row.names = FALSE)
conti_categ <- unique(c(conti_categ, 'sizeFactor'))

```

# Unsupervized analyses

## Regressing covariates ?

```{r clreg}
# covar_factor_names <- c(NULL)
covar_factor_names <- c('Liver_type')

covar_conti_names <- c(NULL)
# covar_conti_names <- c('sizeFactor')


covar_factor_df <- if(!is.null(covar_factor_names)) as.data.frame(de2.norm@colData@listData[covar_factor_names]) else NULL
covar_conti_df <- if(!is.null(covar_conti_names)) as.data.frame(de2.norm@colData@listData[covar_conti_names]) else NULL

if (all(is.null(c(covar_factor_names, covar_conti_names)))) {
  supervised_mat <- SummarizedExperiment::assay(de2.norm)
  supervised_word <- 'NO_regression'
} else {
  supervised_mat <- matrix_covar_regress(mat = SummarizedExperiment::assay(de2.norm), covar_factor_df = covar_factor_df, covar_conti_df = covar_conti_df, type = 'norm')
  supervised_word <- paste0('Regression_', paste(c(covar_factor_names, covar_conti_names), collapse = '.'))
}

## Save the matrix
reg_df <- data.frame(Feature=rownames(supervised_mat), supervised_mat)
WriteXLS::WriteXLS(x = reg_df, ExcelFileName = paste0(work_dir, '/Normalized_expression_matrix_', supervised_word, '.xlsx'), AdjWidth = TRUE, BoldHeaderRow = TRUE, na = 'NA')
rm(reg_df)

```

## Assess covariates

```{r diffexp}
asscov_dir <- paste0(work_dir, '/Covariates_assessment')
dir.create(path = asscov_dir, recursive = TRUE)
## Topvar
topword <- if (!is.null(topvar)) paste0('topvar.', topvar) else topvar
assess_covar(mat = SummarizedExperiment::assay(de2.norm), annot.df = de2.norm@colData, factor.names = unname(unlist(box_categ)), conti.names = unname(unlist(conti_categ)), red.method = 'pca', ndim.max = 10, topvar = topvar, center = TRUE, scale = TRUE, out.file = paste0(asscov_dir, '/', paste(c('covar', 'raw', topword), collapse = '_'), '.svg'))
## All genes
assess_covar(mat = SummarizedExperiment::assay(de2.norm), annot.df = de2.norm@colData, factor.names = unname(unlist(box_categ)), conti.names = unname(unlist(conti_categ)), red.method = 'pca', ndim.max = 10, topvar = nrow(de2.norm), center = TRUE, scale = TRUE, out.file = paste0(asscov_dir, '/', paste(c('covar', 'raw', 'all'), collapse = '_'), '.svg'))

## If a regressed matrix exists
if (!all(is.null(c(covar_factor_names, covar_conti_names)))) {
  asscovreg_dir <- paste0(asscov_dir, '/Regressed')
  dir.create(path = asscovreg_dir, recursive = TRUE)
  ## Topvar
  topword <- if (!is.null(topvar)) paste0('topvar.', topvar) else topvar
  assess_covar(mat = supervised_mat, annot.df = de2.norm@colData, factor.names = unname(unlist(box_categ)), conti.names = unname(unlist(conti_categ)), red.method = 'pca', ndim.max = 10, topvar = topvar, center = TRUE, scale = TRUE, out.file = paste0(asscovreg_dir, '/', paste(c('covar', 'raw', 'regressed', topword), collapse = '_'), '.svg'))
  ## All genes
  assess_covar(mat = supervised_mat, annot.df = de2.norm@colData, factor.names = unname(unlist(box_categ)), conti.names = unname(unlist(conti_categ)), red.method = 'pca', ndim.max = 10, topvar = nrow(de2.norm), center = TRUE, scale = TRUE, out.file = paste0(asscovreg_dir, '/', paste(c('covar', 'raw', 'regressed', 'all'), collapse = '_'), '.svg'))
}

```

## PCA

PCA is used to evaluate how the data dimensionality could be reduced from our multiple samples. Working on human data, we do not expect by default a high representation of the variance by a very limited set of very first components. It is also used to detect outlying samples, and in best cases gives ideas of the data structure (ie, most evident clusters).

```{r pca, message=FALSE, eval = FALSE}
## PCAs on normalized assay
pca_dir <- paste0(work_dir, '/PCA')
dir.create(path = pca_dir, recursive = TRUE)
### Categorical data
for (bc in names(box_categ)) {
  suppressWarnings(de2.pca.batch <- DESeq2::plotPCA(de2.norm, intgroup = box_categ[[bc]], ntop = topvar))
  svg(filename = paste0(pca_dir, '/PCA_', box_categ[[bc]], '.svg'), width = 1600/96, height = 1200/96)
  suppressWarnings(print(de2.pca.batch + ggplot2::geom_point(data = data.frame(PC1 = get_medoid(x = de2.pca.batch$data$PC1, split = de2.pca.batch$data$group), PC2 = get_medoid(x = de2.pca.batch$data$PC2, split = de2.pca.batch$data$group), group = levels(de2.pca.batch$data$group)), shape = 13, size = 8) + ggplot2::labs(title = bc)))
  svg_off()
}
### Continuous
rv <- matrixStats::rowVars(SummarizedExperiment::assay(de2.norm))
rv_selec <- order(rv, decreasing = TRUE)[seq_len(min(topvar, length(rv)))]
for (conti.annot in unlist(conti_categ)) {
  pca_res <- prcomp(t(SummarizedExperiment::assay(de2.norm)[rv_selec,]))
  percentVar <- pca_res$sdev^2/sum(pca_res$sdev^2)
  d <- data.frame(PC1 = pca_res$x[, 1], PC2 = pca_res$x[, 2], annot = de2@colData[[conti.annot]])
  colnames(d)[3] <- conti.annot
  ggp <- ggplot(data = d, aes_string(x = "PC1", y = "PC2", color = conti.annot)) + 
          geom_point(size = 3) + xlab(paste0("PC1", round(percentVar[1] * 
          100), "% variance")) + ylab(paste0("PC2: ", round(percentVar[2] * 
          100), "% variance")) + coord_fixed() + ggtitle(label = conti.annot)
  svg(filename = paste0(pca_dir, '/PCA_', conti.annot, '.svg'), width = 1600/96, height = 1200/96)
  print(ggp)
  svg_off()
}

## If a regressed matrix exists
if (!all(is.null(c(covar_factor_names, covar_conti_names)))) {
  ## Output dir
  pcareg_dir <- paste0(pca_dir, '/regressed')
  dir.create(path = pcareg_dir, recursive = TRUE)
  ## Categorical data
  de2.norm.reg <- de2.norm
  SummarizedExperiment::assay(de2.norm.reg) <- supervised_mat
  for (bc in names(box_categ)) {
    suppressWarnings(de2.pca.batch <- DESeq2::plotPCA(de2.norm.reg, intgroup = box_categ[[bc]], ntop = topvar))
    svg(filename = paste0(pcareg_dir, '/PCA_', box_categ[[bc]], '_regressed.svg'), width = 1600/96, height = 1200/96)
    suppressWarnings(print(de2.pca.batch + ggplot2::geom_point(data = data.frame(PC1 = get_medoid(x = de2.pca.batch$data$PC1, split = de2.pca.batch$data$group), PC2 = get_medoid(x = de2.pca.batch$data$PC2, split = de2.pca.batch$data$group), group = levels(de2.pca.batch$data$group)), shape = 13, size = 8) + ggplot2::labs(title = bc)))
    svg_off()
  }
  rm(de2.norm.reg)
  ## Continuous
  rv <- matrixStats::rowVars(supervised_mat)
  rv_selec <- order(rv, decreasing = TRUE)[seq_len(min(topvar, length(rv)))]
  for (conti.annot in unlist(conti_categ)) {
    pca_res <- prcomp(t(supervised_mat[rv_selec,]))
    percentVar <- pca_res$sdev^2/sum(pca_res$sdev^2)
    d <- data.frame(PC1 = pca_res$x[, 1], PC2 = pca_res$x[, 2], annot = de2@colData[[conti.annot]])
    colnames(d)[3] <- conti.annot
    ggp <- ggplot(data = d, aes_string(x = "PC1", y = "PC2", color = conti.annot)) + 
            geom_point(size = 3) + xlab(paste0("PC1", round(percentVar[1] * 
            100), "% variance")) + ylab(paste0("PC2: ", round(percentVar[2] * 
            100), "% variance")) + coord_fixed() + ggtitle(label = conti.annot)
    svg(filename = paste0(pcareg_dir, '/PCA_', conti.annot, '_regressed.svg'), width = 1600/96, height = 1200/96)
    print(ggp)
    svg_off()
  }
}

## Continuous data (WIP)
library(ggfortify)
    for (p in c(cur.cond, cur.covars)) {
      pf <- paste0(de.dir, '/PCA_vst_', p, '.svg')
      ph <- 1000
      pw <- 1100
      svg(filename = pf, width = pw/96, height = ph/96)
      try(print(ggplot2::autoplot(prcomp(t(norm.mat)), data = as.data.frame(SummarizedExperiment::colData(DE2obj)), colour = p, size = 3)), silent = TRUE)
      svg_off()
    }
}

```

*Conclusion* :

* PC1 represents ~ XX% of the total variance.
* Lorem.
* Ipsum.

## Clustering

```{r clustdir}
clust_dir <- paste0(work_dir, '/Clustering/', supervised_word)

```

### Hierarchical

Hierarchical clustering is the rough, basic family of clustering methods. It has several variations based on its two main steps : 

* Computation of distances between all pairs of samples : there are multiple types of computing a distance between entities (mainly, in genomics : Euclidean, pearson/spearman, manhattan, maximum, ...).
* Aglomeration method, the way to construct a structure from the collection (half-matrix) of distances : as well, there are multiple methods (mainly : Ward, complete, median, ...)

As we have no a priori clue of the expression pattern of the differences between conditions / samples, we cannot know which distance and aglomeration method combination is better suited to measure these differences. Thus, multiple methods should be tested.

```{r hclust}
hc_dir <- paste0(clust_dir, '/Hierarchical')
dir.create(path = hc_dir, recursive = TRUE)

```


### Skmeans

```{r skmeans}
## skmeans, kmndirs package missing !!

sk_dir <- paste0(clust_dir, '/SKmeans')
dir.create(path = sk_dir, recursive = TRUE)

ranks <- 2:5

## Genetic
sk_method <- 'genetic'
skmeans_run(data = supervised_mat, k.test = ranks, method = sk_method, control = list(maxiter = 50, popsize = 6, mutations = .1), odir = sk_dir)
## pclust
sk_method <- 'pclust'
skmeans_run(data = supervised_mat, k.test = ranks, method = sk_method, control = list(maxiter = 100, nruns = 100, maxchains = 0), odir = sk_dir)
## kmndirs
# sk_method <- 'kmndirs'
# skmeans_run(data = supervised_mat, k.test = ranks, method = sk_method, control = list(nstart = 50, maxiter = 100), odir = sk_dir)
## gmeans
sk_method <- 'gmeans'
sk_gmethods <- c('s', 'e', 'b', 'k', 'd')
g_path <- "/home/job/WORKSPACE/TOOLS/gmeans-ansi-compliant/gmeans-"
for (skg in sk_gmethods) {
  message(paste0('gmeans : ', skg))
  try(skmeans_run(data = supervised_mat, k.test = ranks, method = sk_method, control = list(gmeans = g_path, control = paste0(' -a ', skg)), odir = sk_dir))
}
## CLUTO
sk_method <- 'cluto'
sk_cmethods <- c('rbr', 'rb', 'direct', 'agglo', 'graph', 'bagglo')
v_path <- "/home/job/WORKSPACE/TOOLS/cluto-2.1.2/Linux-x86_64/vcluster"
for (skc in sk_cmethods) {
  message(paste0('cluto : ', skc))
  try(skmeans_run(data = supervised_mat, k.test = ranks, method = sk_method, control = list(vcluster = v_path, control = paste0(' -clmethod=', skc)), odir = sk_dir))
}

```


### NMF

```{r nmf}

## NMF package missing !
## Install this way :
## devtools::install_github('renozao/pkgmaker')
## devtools::install_github('renozao/NMF@devel')
## install.packages('bigmemory')
## install.packages('synchronicity')

nmf_dir <- paste0(clust_dir, '/NMF')
dir.create(path = nmf_dir, recursive = TRUE)

nmf_methods()
# nmf_method <- 'brunet'
# nmf_method <- 'Frobenius'
# nmf_method <- 'KL'
# nmf_method <- 'lee'
# nmf_method <- 'offset'
# nmf_method <- 'nsNMF'
# nmf_method <- 'ls-nmf'

ranks <- 2:5
nrun <- 30
maxIter <- 5000
ncores <- 4
classes <- as.data.frame(de2.norm@colData@listData)[,c(unname(unlist(box_categ)))]
for (x in unname(unlist(box_categ))) classes[[x]] <- as.factor(classes[[x]])

nmfmethods <- c('brunet', 'Frobenius', 'KL', 'lee', 'ls-nmf', 'nsNMF', 'offset')
nmfmethods <- c('offset')

for (nmfm in nmfmethods) {
  message(nmfm)
  nmf_run(data = supervised_mat, ranks = ranks, method = nmfm, default_seed_method = "none", my_seed = 1337, nrun = nrun, maxIter = maxIter, shift.if.neg = TRUE, classes = classes, ncores = ncores, odir = nmf_dir, shuffle = TRUE, shuffle.factor = .5, shared.memory = TRUE)
}

```


### Clustering vs annotation

Here we will test if unsupervised clusters may associate with annotation data
```{r cvsa}

## Load clustering results
# clust_res_xlsx <- "~/WORKSPACE/PROJECTS/B240XX CEPO_XX_PRTK-PEACE1_TNE_nCounter/RESULTS/PEACE1_nCounter.QC.Filtered_CORRECTED.COUNTS_FILTER.HIGH_20240821155727/QC/Cohort_annotation_QCfiltered_Clustering.xlsx"
clust_res_xlsx <- "~/WORKSPACE/PROJECTS/B240XX CEPO_XX_PRTK-PEACE1_TNE_nCounter/RESULTS/PEACE1_nCounter.QC.Filtered_CORRECTED.COUNTS_FILTER.HIGH_20240821155727/DEA_20241018110957/Annotation_with_clusters_194s.xlsx"
clust_res_df <- as.data.frame(readxl::read_excel(clust_res_xlsx, na = c(NA, 'NA', '')))

## Categorical
cvsa_dir <- paste0(clust_dir, '/Clustering_vs_annotation/Categorical')
dir.create(path = cvsa_dir, recursive = TRUE)

chifisher(
  annot.table = clust_res_df
  , query.vec = grep(pattern = '^(REG|DEA)_', x = colnames(clust_res_df), value = TRUE)
  , target.vec = unlist(box_categ)
  , test.type = 'F'
  , test.type.2 = 'W'
  , test.type.N = 'KW'
  , numeric.as.continuous = FALSE
  , out.dir = cvsa_dir
)

## continuous
cvsa_dir <- paste0(clust_dir, '/Clustering_vs_annotation/Continuous')
dir.create(path = cvsa_dir, recursive = TRUE)

chifisher(
  annot.table = clust_res_df
  , query.vec = grep(pattern = '^(REG|DEA)_', x = colnames(clust_res_df), value = TRUE)
  , target.vec = unlist(conti_categ)
  , test.type = 'F'
  , test.type.2 = 'W'
  , test.type.N = 'KW'
  , numeric.as.continuous = TRUE
  , out.dir = cvsa_dir
)

```


# Differential analysis

## DESeq2

### DEA on all possible comparisons

Differential expression analysis is performed using DESeq2 on the generated design.

```{r dea_all, eval = FALSE}
diff_dir <- paste0(work_dir, '/Differential_analysis')
dir.create(path = diff_dir, recursive = TRUE)

## RESPONDER STATUS
diff_categ <- c(
  # 'PFS.3_m'
  # ,
  # 'PFS.12_m'
  # ,
  'PFS.3.12_m'
)


## Covariates
covariates <- list(c(NULL))
covariates <- list(c('Liver_type'))
covariates <- list(c('Liver_type', 'TC.pc'))
covariates <- list(c('Pathology'))
covariates <- list(c('TC.pc'))
covariates <- list(c('Type_of_sample'))
covariates <- list(c('Liver_type', 'Pathology'))
covariates <- list(c('Type_of_sample', 'Pathology'))
covariates <- list(c('Type_of_sample', 'TC.pc'))
covariates <- list(c('Dose_mg'))
covariates <- list(c('Pathology'))
covariates <- list(c('TC.pc'))
covariates <- list(c('Reads_by_run'))
covariates <- list(c('Liver_type', 'Dose_mg'))
covariates <- list(c('Liver_type', 'TC.pc'))
covariates <- list(c('TC.pc', 'Dose_mg'))
covariates <- list(c('Liver_type', 'TC.pc', 'Dose_mg'))

# covariates <- list(
#   c('Liver_type', 'TC.pc')
#   # ,
#   # c('Liver_type', 'TC.pc')
#   # ,
#   # c('Liver_type', 'TC.pc')
# )



### Generating the full design file
my_des <- full_design_generator(
  init_df = as.data.frame(de2.norm@colData[,c(annot_sn, unlist(diff_categ))])
  , 
  samples_colname = annot_sn
  , 
  covar_colnames = covariates
  , 
  add_inverted = TRUE
  , 
  add_others = TRUE
  , 
  only_others = FALSE
)
## TEMP
# my_des <- my_des[1,, drop = FALSE]
# my_des <- my_des[c(2,3,6:9),, drop = FALSE]
# my_des <- my_des[2,, drop = FALSE]
# my_des <- my_des[8:9,, drop = FALSE]
# my_des <- my_des[c(2,3,6),, drop = FALSE]
# my_des <- my_des[c(7,8),, drop = FALSE]
my_des <- my_des[9,, drop = FALSE]

## Generating temporary de2 object
for(dc in unlist(diff_categ)) de2[[dc]] <- as.factor(de2[[dc]])
de2.temp <- de2

### Removing samples with NA in diff_categ and/or covariates
nacolz <- c(diff_categ, unique(unlist(covariates)))
covna <- as.data.frame(lapply(nacolz, function(x) { is.na(de2[[x]])}))
colnames(covna) <- nacolz
samp2keep <- rowSums(covna) == 0
de2.temp <- de2.temp[,samp2keep]

## assess_covariates
de2.temp.norm <- DESeq2::vst(object = de2.temp, blind = TRUE, nsub = topvar)
## Topvar
topword <- if (!is.null(topvar)) paste0('topvar.', topvar) else topvar
assess_covar(mat = SummarizedExperiment::assay(de2.temp.norm), annot.df = de2.temp.norm@colData, factor.names = unname(unlist(box_categ)), conti.names = unname(unlist(conti_categ)), red.method = 'pca', ndim.max = 10, topvar = topvar, center = TRUE, scale = TRUE, out.file = paste0(diff_dir, '/', paste(c('covar', 'raw', diff_categ[1], topword), collapse = '_'), '.svg'))
## All
assess_covar(mat = SummarizedExperiment::assay(de2.temp.norm), annot.df = de2.temp.norm@colData, factor.names = unname(unlist(box_categ)), conti.names = unname(unlist(conti_categ)), red.method = 'pca', ndim.max = 10, topvar = nrow(de2.temp.norm), center = TRUE, scale = TRUE, out.file = paste0(diff_dir, '/', paste(c('covar', 'raw', diff_categ[1], 'all'), collapse = '_'), '.svg'))


## GO!

# suppressMessages(
  DEA_run(
    ## Raw count matrix
    exp.mat = SummarizedExperiment::assay(de2.temp)
    , 
    ## Sample annotation
    annot.df = as.data.frame(de2.temp@colData)
    , 
    ## Design table
    design.df = my_des
    , 
    ## Factors to evaluate as putative categorical covariates
    # assess.factor = unname(unlist(box_categ))
    assess.factor = NULL
    , 
    ## Numerics to evaluate as putative continuous covariates
    # assess.conti = unname(unlist(conti_categ))
    assess.conti = NULL
    , 
    ## Number of features to use for VST modelization and PCA
    vst_nsub = topvar
    , 
    ## Max FDR-adjusted p-value threshold for differential features
    adjp.max = adjp.max
    , 
    ## Min abs(log2FoldChange)to identify differential features
    lfc.min = lfc.min
    , 
    ## Minimum total count per class to keep a feature
    min_count = min_count
    , 
    ## Minimum fraction of samples with counts (per class) to keep a feature
    min_sample_freq = min_sample_freq
    , 
    ## Compute min_count and min_samples per-class rather than on full cohort
    per_class = TRUE
    , 
    ## Perform ihw log2FoldChange adjustment
    ihw = TRUE
    , 
    ## Perform log2FoldChange shrinking on lower values
    lfcShrink = TRUE
    , 
    ## Max FDR-adjusted p-value threshold for enriched GSEA/ORA terms
    enrp.max = adjp.max
    , 
    ## Distance(s) for samples to use for hierarchical clustering on differentially expressed features
    samples.dist.method = samples_dist_method
    , 
    ## Minimal size of significant features to run GSEA / ORA
    enr.min.genes = enr_min_genes
    , 
    ## Use the MSigDB resources (through msigdbr) for GSEA / ORA
    msigdb.do = msigdb.do
    , 
    ## Use the DiseaseOntology resources (through DOSE) for GSEA / ORA
    do.do = do.do
    , 
    ## Use the GeneOntology resources for GSEA / ORA
    go.do = go.do
    , 
    ## Use the KEGG/MKEGG resources for GSEA / ORA
    kegg.do = kegg.do
    , 
    ## Use the WikiPathways resources for GSEA / ORA
    wp.do = wp.do
    , 
    ## Use the Reactome resources for GSEA / ORA
    reactome.do = reactome.do
    , 
    ## Use the NCBI MeSH resources for GSEA / ORA (*not recommended*)
    mesh.do = mesh.do
    , 
    ## Use custom term banks
    custom.do = custom.do
    , 
    ## List of term banks to use if custom.do is TRUE
    custom_gmt_list = custom_gmt_list
    , 
    ## Force GSEA even when there are not enough sig genes
    gsea.force = TRUE
    , 
    ## Species name (to convert symbols to EntrezId)
    species = species
    , 
    ## RNG seed
    my.seed = my_seed
    , 
    ## Save the Wald test results as RDS (can be huge)
    save.wald = FALSE
    , 
    ## Path to result files
    outdir = work_dir
  )
# )

```

*NOTE* : DEA generates numerous tables, data archives and plots (thousands), thus results are not available in this report.

Additional GSEA for selected WP and KEGG terms

```{r gsea_selec}

## Load and restrict banks
gmt_selec_list <- list()

## WikiPathways selection
wp_list <- c('WP254', 'WP4923', 'WP673', 'WP3844', 'WP35', 'WP5300', 'WP4752', 'WP707', 'WP531', 'WP4946', 'WP466', 'WP186', 'WP438', 'WP4753', 'WP2881', 'WP712', 'WP722', 'WP732', 'WP733', 'WP734', 'WP23', 'WP3929', 'WP558', 'WP4655', 'WP5072', 'WP288', 'WP3865', 'WP69', 'WP5130', 'WP75', 'WP2583', 'WP4262', 'WP4585')

### Load full WP gmt to df (as expected by clusterProfiler)
wp_gmt <- clusterProfiler::read.gmt(gmtfile = wp_gmt_file)
### Restrict to the requested ones
w_ids <- unname(vapply(as.character(wp_gmt$term), function(x) { unlist(strsplit(x = x, split = '\\%'))[3] }, 'a'))
w_comx <- w_ids %in% sort(unique(wp_list))
gmt_selec_list[['WP_selec']] <- data.frame(term = as.factor(w_ids[w_comx]), gene = wp_gmt$gene[w_comx], stringsAsFactors = FALSE)
rm(wp_gmt, w_ids, w_comx)

## KEGG selection
kegg_list <- c('4210', '4110', '4140', '4144', '4142', '4370', '4012', '4066', '4150', '4151', '3410', '3430', '3030', '3440', '3450', '3420', '4915', '4662', '4062', '4610', '4659', '4621', '4622', '4660', '4659', '4620', '5224', '5235', '5223')

### Load full WP gmt to df (as expected by clusterProfiler)
kegg_gmt <- clusterProfiler::read.gmt(gmtfile = kegg_gmt_file)
### Restrict to the requested ones
k_ids <- vapply(as.character(kegg_gmt$term), function(x) { sub(pattern = 'hsa', replacement = '', x = unlist(strsplit(x = x, split = '_'))[1]) }, 'a')
k_comx <- k_ids %in% sort(unique(paste0('0', kegg_list)))
gmt_selec_list[['KEGG_selec']] <- data.frame(term = as.factor(k_ids[k_comx]), gene = kegg_gmt$gene[k_comx], stringsAsFactors = FALSE)
rm(kegg_gmt, k_ids, k_comx)

## Looping on DEA results
DEA_res_list <- list.files(path = work_dir, pattern = '_results.tsv.gz$', all.files = TRUE, recursive = TRUE, full.names = TRUE)

for (f in seq_along(DEA_res_list)) {
  ## Load DEA results
  dea_res <- read.table(file = DEA_res_list[f], header = TRUE, sep = '\t')
  ### Convert to expected query format
  t2e <- table2enr(deseq2.res.data = dea_res, species = species, geneid.colname = 'Symbol', geneid.type = 'SYMBOL', stat.colname = 'log2FoldChange', topN.max = 100, p.colname = 'padj', p.cutoff = adjp.max, stat.keep.operator = '>' )
  
  ## Looping on custom banks
  for (bs in names(custom_gmt_list)) {
    ### GSEA
    suppressMessages(suppressWarnings(gsea_res <- gsea_run(geneList = t2e$gsea.genevec, func.name = 'clusterProfiler::GSEA', species = species, t2g = custom_gmt_list[[bs]], t2g.name = bs, gene2Symbol = t2e$gene2Symbol, seed = my_seed, pvalueCutoff = adjp.max, minGSSize = enr_min_genes)))
    ## GSEA plots
    gsea_output(gseaResult = gsea_res, out.dir = dirname(DEA_res_list[f]), comp.name = basename(dirname(DEA_res_list[f])))
    
    ### ORA
    suppressMessages(suppressWarnings(ora_res <- ora_run(gene = t2e$ora.genevec, species = species, func.name = 'clusterProfiler::enricher', t2g = custom_gmt_list[[bs]], t2g.name = bs, gene2Symbol = t2e$gene2Symbol, pvalueCutoff = adjp.max, minGSSize = enr_min_genes)))
    ### ORA plots
    ora_output(enrichResult = ora_res, out.dir = dirname(DEA_res_list[f]), comp.name = basename(dirname(DEA_res_list[f])), geneList = t2e$gsea.genevec)
  }
}
```

# Expression correlation

. Here we will simply try to evaluate the direct correlation (Spearman) of a continuous annotation with our genes expression

```{r expcor}
## Output directory
cor_dir <- paste(c(work_dir, 'Gene-annotation_correlation'), collapse = '/')
dir.create(path = cor_dir, recursive = TRUE)

## WIP
annot.to.cor <- unlist(conti_categ)
cor_method <- 'spearman'
cor_adjp.max <- .05

### Compute correlation
for (atc in annot.to.cor) {
  message(atc)
  cor_df <- data.frame(t(supervised_mat), check.names = FALSE)
  cor_df[[atc]] <-  de2.norm@colData[[atc]]
  system.time(cor_res <- rstatix::cor_test(data = cor_df, vars = rownames(supervised_mat), vars2 = atc, method = cor_method))
  cor_res$p_adj <- p.adjust(p = cor_res$p, method = 'BH')
  cor_res$cor_abs <- abs(cor_res$cor)
  cor_res[[paste0('Sig@', cor_adjp.max)]] <- cor_res$p_adj < cor_adjp.max
  cor_res <- cor_res[order(cor_res$cor, decreasing = TRUE),]
  ## Save as RDS
  saveRDS(object = cor_res, file = paste0(cor_dir, '/Correlation_genes-x-', atc, '_', cor_method, '.RDS'), compress = 'bzip2')
  ## Save as MS Excel
  WriteXLS::WriteXLS(x = cor_res, ExcelFileName = paste0(cor_dir, '/Correlation_genes-x-', atc, '_', cor_method, '_results.xlsx'), SheetNames = atc, AdjWidth = TRUE, AutoFilter = TRUE, BoldHeaderRow = TRUE, FreezeRow = 1, FreezeCol = 1, na = c(NA, 'NA', 'na', ''))
}

### Visualize
# for (atc in annot.to.cor) {
#   message(atc)
#   corrplot::corrplot(corr = cor_res$m, type = 'upper', method = 'square', order = 'hclust', hclust.method = 'ward.D', p.mat = cor_res$p_adj, sig.level = cor_adjp.max, insig = 'blank', method = 'square', title = paste0('Gene expression ', cor_method, ' correlation with ', atc), outline = FALSE, )

```


# Immune deconvolution

. This analysis will attempt an estimation of the immune composition of each of the expression profiles.
. This is performed thanks to the [*immunedeconv*](https://github.com/omnideconv/immunedeconv) R package, which regroups multiple methods.
. Most methods require expression data to be in TPM (transcripts per million : the sum of all counts in a sample always equals 1E+06), not normalized (vst, etc) not log-scaled
. All tested methods can be used to compare proportions/scores across samples or sample groups.
. Most methods have their specificities :
  . QuantiSeq : returns proportions (between 0 and 1)
  . EPIC : same as QuantiSeq, but is the only one that also computes the fraction of uncharachterized cells
  . MCPCounter : scores each cell mixture in arbitrary units
  . CiberSort (v1.06) : must be run here in "absolute" mode to allow comparison across samples
  . CiberSortX : same as CiberSort, but is more recent and trained on scRNAseq data. Was manually performed [online](https://cibersortx.stanford.edu/).
  . ESTIMATE : simpler algotithm that was designed for evaluation of tumoral purity. Consequently, does not return fractions for specific immune subpopulations but 4 scores (global "estimate", immune, stroma and tumor)


## Deconvolution

```{r id_deconv}

## Output directory
deconv_suffix <- if (!is.null(salmon_pipeline_tpm_file)) 'from.Salmon.Pipeline' else 'from.DESeq2'
id_dir <- paste(c(work_dir, 'ImmuneDeconv', deconv_suffix), collapse = '/')
dir.create(path = id_dir, recursive = TRUE)

## From the Salmon pipeline or not ?
if (!is.null(salmon_pipeline_tpm_file)) {
  ## Load the TPM flat file
  pip_tpm_df <- as.data.frame(data.table::fread(file = tpm_file, sep = '\t', header = TRUE))
  ## Convert to matrix
  exp_deconv_mat <- as.matrix(pip_tpm_df[,-c(1, ncol(pip_tpm_df))])
  ## Add symbols as rownames
  rownames(exp_deconv_mat) <- pip_tpm_df$Hugo_ID
  rm(pip_tpm_df)
  ## Remove un-annotated samples
  exp_deconv_mat <- exp_deconv_mat[,colnames(exp_deconv_mat) %in% de2@colData[[annot_sn]]]
  ## Remove genes with unknown symbol
  exp_deconv_mat <- exp_deconv_mat[!rownames(exp_deconv_mat) %in% c('Unknown'),]
  ## Remove symbol duplicates
  exp_deconv_mat <- exp_deconv_mat[!duplicated(rownames(exp_deconv_mat)),]
  
  ### Write the cibersortx-formatted table
  write.table(x = data.frame(Symbol = rownames(exp_deconv_mat), exp_deconv_mat), file = paste0(id_dir, '/CIBERSORTx_TPM_', deconv_suffix, '.tsv'), sep = '\t', quote = FALSE, row.names = FALSE)
  
  ## Set options for immunedeconv_run
  to_tpm <- FALSE
  
} else {
  ## Create CIBERSORTx TPM matrix from the DEseq Object
  exp_deconv_mat <- SummarizedExperiment::assay(de2)
  
  ## Handle regression if needed, thanks to ComBat_seq
  if(!is.null(covar_conti_names)) stop("Can't regress continuous covariate with ComBat_seq ...")
  if(!is.null(covar_factor_names)) {
    if(length(covar_factor_names) > 1) stop("Can't regress multiple categorical covariates with ComBat_seq ...")
    exp_deconv_mat <- sva::ComBat_seq(counts = exp_deconv_mat, batch = de2@colData[[covar_factor_names]], group = NULL, full_mod = FALSE)
  }
  ## Convert counts to TPM
  ### TXDB version
  library(TxDb.Hsapiens.UCSC.hg38.knownGene)
  tx_by_gene <- GenomicFeatures::transcriptsBy(TxDb.Hsapiens.UCSC.hg38.knownGene, by="gene")
  glens <- max(width(tx_by_gene))
  entrez2symb <- clusterProfiler::bitr(geneID = names(glens), fromType = "ENTREZID", toType = "SYMBOL", OrgDb = 'org.Hs.eg.db', drop = TRUE)
  ### Clean
  symb_tbl <- table(entrez2symb$SYMBOL)
  entrez_tbl <- table(entrez2symb$ENTREZID)
  symb_out <- unique(names(symb_tbl)[symb_tbl > 1])
  entrez_out <- unique(names(entrez_tbl)[entrez_tbl > 1])
  entrez2symb <- entrez2symb[!(entrez2symb$SYMBOL %in% symb_out) & !(entrez2symb$ENTREZID %in% entrez_out),]
  symb2entrez_vec <- setNames(object = entrez2symb$SYMBOL, nm = entrez2symb$ENTREZID)
  ### Convert glen names to symbols
  names(glens) <- symb2entrez_vec[names(glens)]
  ### Synch with the matrix
  exp_deconv_mat <- exp_deconv_mat[rownames(exp_deconv_mat) %in% names(glens),]
  glens <- glens[names(glens) %in% rownames(exp_deconv_mat)]
  exp_deconv_mat <- exp_deconv_mat[order(rownames(exp_deconv_mat)),]
  glens <- glens[order(names(glens))]
  all(rownames(exp_deconv_mat) == names(glens))
  
  ### Convert counts to TPM
  x <- exp_deconv_mat / glens
  exp_deconv_mat <- t(t(x) * 1E+06 / colSums(x))
  rm(x)
  
  ### Export
  write.table(x = data.frame(Symbol = rownames(exp_deconv_mat), exp_deconv_mat), file = paste0(id_dir, '/', paste(c('CIBERSORTx', 'TPM', supervised_word), collapse = '_'), '.tsv'), sep = '\t', quote = FALSE, row.names = FALSE)
  
  ## Set options for immunedeconv_run
  to_tpm <- FALSE
}

## Manually perform the cibersortx (https://cibersortx.stanford.edu/runcibersortx.php) and ecotyper (https://ecotyper.stanford.edu/) analyses, then save results as cibersortx_resfile and ecotyper_resfile

## Run immunedeconv
id_res_all <- immunedeconv_run(
  exp_mat = exp_deconv_mat
  , to_tpm = to_tpm
  , methods = id_methods
  , is_array = is_array
  , is_tumor = is_tumor
  , cibersort_binary_path = cibersort_binary_path
  , cibersort_lm22_path = cibersort_lm22_path
  , cibersort_absolute = cibersort_absolute
  , cibersortx_resfile = cibersortx_resfile
  , cibersortx_absolute = cibersortx_absolute
  , ecotyper_resfile = ecotyper_resfile
)

## Save results
writexl::write_xlsx(x = id_res_all, path = paste0(id_dir, '/immunedeconv_results_', deconv_suffix, '.xlsx'), col_names = TRUE, format_headers = TRUE)

```

## Barplots

```{r id_barplots}

## Barplots
for (idm in names(id_res_all)) {
  message(idm)
  immunedeconv_barplot(id_res = id_res_all[[idm]], title = idm)
  png(filename = paste0(id_dir, '/', idm, '_barplot.png'), width = 1200, height = 1600)
  immunedeconv_barplot(id_res = id_res_all[[idm]], title = idm)
  dev.off()
}

```


## Proportion tests

The association of proportion differences with sample annotations is tested through a Kruskal-Wallis test.

### Building custom factors

Here we cross some annotation to focus on subpopulations.

```{r cross1}
# facz <- c('TimePoint', 'Response_status_confirmed')
# facx <- paste(facz, collapse = '_')
# de2.norm[[facx]] <- paste(de2.norm[[facz[1]]], de2.norm[[facz[2]]], sep = '_')
# for (x in c(facz, facx)) de2.norm[[x]] <- as.factor(de2.norm[[x]])
# prop_factors <- sort(unique(c(prop_factors, facz)))
# for (y in levels(de2.norm[[facz[1]]])) {
#   facy <- paste0(facz[2], '_in_', y)
#   de2.norm[[facy]] <- de2.norm[[facz[2]]]
#   fac2do <- de2.norm[[facz[1]]] == y
#   de2.norm[[facy]][!fac2do] <- NA
#   prop_factors <- sort(unique(c(prop_factors, facy)))
# }
# for (y in levels(de2.norm[[facz[2]]])) {
#   facy <- paste0(facz[1], '_in_', y)
#   de2.norm[[facy]] <- de2.norm[[facz[1]]]
#   fac2do <- de2.norm[[facz[2]]] == y
#   de2.norm[[facy]][!fac2do] <- NA
#   prop_factors <- sort(unique(c(prop_factors, facy)))
# }

prop_factors <- c('TimePoint', 'Response_status_confirmed', 'SK_genetic_2', 'SK_pclust_2', 'SK_gmeans.s_2', 'SK_gmeans.e_2', 'SK_gmeans.k_2', 'NMF_brunet.2', 'NMF_frobenius.2', 'NMF_kl.2', 'NMF_lee.2', 'NMF_lsnmf.2', 'NMF_nsnmf.2', 'NMF_offset.2')
```


```{r id_testprop}

## Looping on factors to compare
kw_all <- lapply(prop_factors, function(ppf) {
  # message(ppf)
  ## Looping on methods
  kw_idm <- lapply(names(id_res_all), function(idn) {
    # message('\t',idn)
    ## Looping on cell types
    kw_l <- sapply(seq_len(nrow(id_res_all[[idn]])), function(x) {
      # message(x)
      ## Perform KW test
      data_df <- data.frame(props = unname(unlist(id_res_all[[idn]][x,-1])), class = de2.norm@colData[[ppf]])
      kw_t <- kruskal.test(props ~ class, data = data_df)
      k_df <- data.frame(Statistic = kw_t$statistic, raw.p = kw_t$p.value, adj.p = 0.0)
      ## Add classes median
      ksumry <- aggregate(props ~ class, data = data_df, summary)
      ksd <- aggregate(props ~ class, data = data_df, sd)
      for (kx in seq_len(nrow(ksumry$props))) {
        k_df[[paste0('Median_', ksumry$class[kx])]] <- ksumry$props[kx, 'Median']
        k_df[[paste0('Sd_', ksd$class[kx])]] <- ksd$props[kx]
      }
      ## Return
      return(k_df)
    }, simplify = FALSE)
    
    kw_res <- data.frame(Cell_type = paste0(idn, '_', unlist(id_res_all[[idn]][,1])), Reduce(f = rbind, x = kw_l))
    kw_res$adj.p <- p.adjust(p = kw_res$raw.p, method = "BH")
    rownames(kw_res) <- paste0(idn, '_', gsub(pattern = "\\W", replacement = '.', x = kw_res$Cell_type))
    return(kw_res)
  })
  names(kw_idm) <- names(id_res_all)
  KWX <- Reduce(f = rbind, kw_idm)
  KWX <- KWX[order(KWX$Cell_type),]
  # KWX$adj.p <- p.adjust(p = KWX$raw.p, method = "BH")
  return(KWX)
})
names(kw_all) <- prop_factors

## Save results
for (k in seq_along(kw_all)) colnames(kw_all[[k]])[1] <- paste0(colnames(kw_all[[k]])[1], ' // ', names(kw_all)[k])


kw_out <- kw_all
kw_out$Legend <- data.frame(Sheet_name = seq_along(kw_all), Cohort = names(kw_all))
kw_out <- kw_out[c(which(names(kw_out) == 'Legend'), which(names(kw_out) != 'Legend'))]
names(kw_out) <- c('Legend', seq_along(kw_all))
WriteXLS::WriteXLS(x = kw_out, ExcelFileName = paste0(id_dir, '/immunedeconv_prop_test_results.xlsx'), AdjWidth = TRUE, AutoFilter = TRUE, BoldHeaderRow = TRUE, FreezeRow = 1, FreezeCol = 1, na = NA)
# writexl::write_xlsx(x = kw_out, path = paste0(id_dir, '/immunedeconv_prop_test_results.xlsx'), col_names = TRUE, format_headers = TRUE)

```


# Gene Set Variance Analysis (GSVA)

. This analysis attempts to compare the expression pattern of each expression profile to a list of banks of knowledge, consisting in (functional) terms associated to known gene signatures. The output is a positive or negative association, with a significance test p-value between the expression profile and terms.
. This is analoguous to GSEA (gene set enrichment analysis) but performed at the sample expression profile level, rather than at the differential expression profile level. In the former, direct expression level is used ; in the latter, logFoldChange/AdjP/Test-statistic is used.
. This is performed using the [*GSVA*](https://bioconductor.org/packages/release/bioc/vignettes/GSVA/inst/doc/GSVA.html) R package.


### GSVA

```{r gsva, eval = FALSE, echo = FALSE}

## Output directories
gsva_dir <- paste0(work_dir, '/GSVA')
gsva_res_dir <- paste0(gsva_dir, '/Results')
dir.create(path = gsva_res_dir, recursive = TRUE)

## Get list of GMT files to use
gmt_files <- list.files(path = gmt_path, pattern = 'entrez.*\\.gmt.*$', full.names = TRUE, recursive = TRUE, ignore.case = TRUE)

## Discard MSigDB GO GMTs (older than BADERLAB versions) and PFOCR (automatic, large)
gmt_files <- gmt_files[!grepl(pattern = '(PFOCR|\\.go\\.)', x = gmt_files)]

## Discard "non-all" MSigDb GMTs
gmt_files <- gmt_files[!(grepl(pattern = 'MSigDB', x = gmt_files)) | (grepl(pattern = '\\.all\\.', x = gmt_files))]

## Discard HumanCyc
gmt_files <- gmt_files[!grepl(pattern = 'HumanCyc', x = gmt_files)]

## Generate GMT names (for output)
gmt_names <- sub(pattern = '\\.gmt.*$', replacement = '', x = basename(gmt_files))


## Run GSVA
gsva_all <- gsva_run(
  exp_mat = supervised_mat
  , gmt_files = gmt_files
  , enr_min_genes = enr_min_genes
  , species = species
  , out_dir = gsva_res_dir
)

```


## Differential tests

We can perform differential test across sample annotations on the GSVA scores

```{r gsva_diff, eval = FALSE, echo = FALSE}
## Output directories
gsva_dir <- paste0(work_dir, '/GSVA')
gsva_diff_dir <- paste0(gsva_dir, '/Diff_tests')
dir.create(path = gsva_diff_dir, recursive = TRUE)

prop_factors <- unique(c(unname(unlist(box_categ)), grep(pattern = 'NMF_', x = colnames(de2.norm@colData), value = TRUE), grep(pattern = 'SK_', x = colnames(de2.norm@colData), value = TRUE)))

gdiff_all <- gsva_diff_run(
  gsva_res = gsva_all
  , annot_df = SummarizedExperiment::colData(de2.norm)
  , diff_factor = prop_factors
  , max.p = adjp.max
  , out_dir = gsva_diff_dir
)

```

# Clinical annotation and discoveries association

Here we want to assess the association of the different sample qualifiers we generated (immune deconvolution and ecotyper results, unsupervised clustering) with the clinical annotation.

```{r}

## Source outside scripts
source_script <- c('ChiFisher.R')
for (ssc in source_script) {
  source(paste(c(root_dir, 'ENV/RNAseqAnalysis/script/R', ssc), collapse = '/'))
}

## Queries
qcateg_vec <- c(grep(pattern = 'NMF_', x = colnames(de2.norm@colData), value = TRUE), grep(pattern = 'SK_', x = colnames(de2.norm@colData), value = TRUE))
qconti_vec <- grep(pattern = '^ID\\.', x = colnames(de2.norm@colData), value = TRUE)
q_vec <- c(qconti_vec, qcateg_vec)

## Targets
tcateg_vec <- c('Pathology', 'Best_response', 'Progression', 'Death_status', 'OS_event', 'Type_of_sample', 'prevICI', 'Visceral_metastasis', 'Bone_metastasis', 'De_novo_metastasis', 'Dose_mg')
tconti_vec <- c('TC.pc', 'Age_at_diag_y', 'Metastatic_line', 'Metastatic_CT_line', 'PFS_m', 'OS_m')
t_vec <- c(tcateg_vec, tconti_vec)

## Load annotation
annot_df <- as.data.frame(readxl::read_excel(path = annot_filename))
colnames(annot_df) <- gsub(pattern = "\\W", replacement = '.', x = colnames(annot_df))

## Output dir
ccda_dir <- paste(c(work_dir, 'Annotation-discoveries_association'), collapse = '/')
dir.create(path = ccda_dir, recursive = TRUE)

## Convert categorical queries to factors
for (qtc in qcateg_vec) annot_df[[qtc]] <- as.factor(annot_df[[qtc]])

## Qcateg / Tcateg : Fisher
qcat_tcat_dir <- paste(c(ccda_dir, 'Qcateg_Tcateg'), collapse = '/')
dir.create(path = qcat_tcat_dir, recursive = TRUE)
chifisher(annot.table = annot_df, query.vec = qcateg_vec, target.vec = tcateg_vec, numeric.as.continuous = TRUE, out.dir = qcat_tcat_dir)

## Qcateg / Tconti : Wilcoxon / KW
qcat_tconti_dir <- paste(c(ccda_dir, 'Qcateg_Tconti'), collapse = '/')
dir.create(path = qcat_tconti_dir, recursive = TRUE)
chifisher(annot.table = annot_df, query.vec = qcateg_vec, target.vec = tconti_vec, numeric.as.continuous = TRUE, out.dir = qcat_tconti_dir)

## Qconti / Tcateg : Wilcoxon / KW
qcont_tcat_dir <- paste(c(ccda_dir, 'Qconti_Tcateg'), collapse = '/')
dir.create(path = qcont_tcat_dir, recursive = TRUE)
chifisher(annot.table = annot_df, query.vec = tcateg_vec, target.vec = qconti_vec, numeric.as.continuous = TRUE, out.dir = qcont_tcat_dir)

## Qconti / Tconti : Spearman correlation
qcont_tcont_dir <- paste(c(ccda_dir, 'Qconti_Tconti'), collapse = '/')
dir.create(path = qcont_tcont_dir, recursive = TRUE)
cor_method <- 'spearman'
# cor_adjp.max <- .05
rc_res <- Hmisc::rcorr(x = as.matrix(annot_df[, colnames(annot_df) %in% qconti_vec]), y = as.matrix(annot_df[, colnames(annot_df) %in% tconti_vec]), type = cor_method)
rc_cor <- rc_res$r[rownames(rc_res$r) %in% tconti_vec, colnames(rc_res$r) %in% qconti_vec]
rc_rawp <- rc_res$P[rownames(rc_res$r) %in% tconti_vec, colnames(rc_res$r) %in% qconti_vec]
rc_adjp <- matrix(p.adjust(p = rc_rawp, method = 'BH'), nrow = nrow(rc_rawp), ncol = ncol(rc_rawp), byrow = TRUE, dimnames = dimnames(rc_rawp))
WriteXLS::WriteXLS(x = list(Spearman = data.frame(Spearman = rownames(rc_cor), rc_cor), AdjP = data.frame(AdjP = rownames(rc_adjp), rc_adjp)), ExcelFileName = paste0(qcont_tcont_dir, '/', cor_method, '_correlation.xlsx'), AdjWidth = TRUE, BoldHeaderRow = TRUE)

### Compute correlation
for (atc in annot.to.cor) {
  message(atc)
  cor_df <- data.frame(t(supervised_mat), check.names = FALSE)
  cor_df[[atc]] <- de2.norm@colData[[atc]]
  cor_res <- rstatix::cor_test(data = cor_df, vars = rownames(supervised_mat), vars2 = atc, method = cor_method)
  cor_res$p_adj <- p.adjust(p = cor_res$p, method = 'BH')
  cor_res$cor_abs <- abs(cor_res$cor)
  cor_res[[paste0('Sig@', cor_adjp.max)]] <- cor_res$p_adj < cor_adjp.max
  cor_res <- cor_res[order(cor_res$cor, decreasing = TRUE),]
  ## Save as RDS
  saveRDS(object = cor_res, file = paste0(cor_dir, '/Correlation_genes-x-', atc, '_', cor_method, '.RDS'), compress = 'bzip2')
  ## Save as MS Excel
  WriteXLS::WriteXLS(x = cor_res, ExcelFileName = paste0(cor_dir, '/Correlation_genes-x-', atc, '_', cor_method, '_results.xlsx'), SheetNames = atc, AdjWidth = TRUE, AutoFilter = TRUE, BoldHeaderRow = TRUE, FreezeRow = 1, FreezeCol = 1, na = c(NA, 'NA', 'na', ''))
}
```

# Survival analysis

## Association with gene expression

```{r survg}
## Output dir
gsurv_dir <- paste(c(work_dir, 'Gene-survival_association'), collapse = '/')
dir.create(path = gsurv_dir, recursive = TRUE)

## Survival analysis

### OS
gsurv.os_dir <- paste0(gsurv_dir, '/OS')
dir.create(path = gsurv.os_dir, recursive = TRUE)
time_data <- de2.norm@colData$OS_m
event_data <- as.numeric(de2.norm@colData$OS_event) ## Check that death positive ends as 2
os_g_res <- lapply(rownames(supervised_mat), function(myg) {
  ### Create temp df
  # assoc_df <- data.frame(time = time_data, status = event_data, gexp = SummarizedExperiment::assay(de2.norm)[myg,])
  assoc_df <- data.frame(time = time_data, status = event_data, gexp = supervised_mat[myg,])
  ### Cox model
  surv_model <- survival::coxph(formula = survival::Surv(time = time, event = status) ~ gexp, data = assoc_df)
  ### Summary to get the p-value
  sm_smry <- summary(surv_model)
  return(c(surv_model$coefficients, surv_model$score, sm_smry$sctest[3]))
})
### Summarize in a df
os_g_df <- data.frame(Gene = rownames(supervised_mat), Reduce(f = rbind, x = os_g_res))
rm(os_g_res)
colnames(os_g_df) <- c('Gene', 'Coefficient', 'Score', 'Raw.p')
os_g_df$Adj.p <- p.adjust(p = os_g_df$Raw.p, method = 'BH')
os_g_df <- os_g_df[order(os_g_df$Score, decreasing = TRUE),]
### Output
WriteXLS::WriteXLS(x = os_g_df, ExcelFileName = paste0(gsurv.os_dir, '/Association_genes-x-OS_coxph_results.xlsx'), SheetNames = 'OS', AdjWidth = TRUE, AutoFilter = TRUE, BoldHeaderRow = TRUE, FreezeRow = 1, FreezeCol = 1)
### GSEA/ORA
#### Read GMTs
gmt_list <- lapply(gmt_files, function(g) { clusterProfiler::read.gmt(gmtfile = g) })
names(gmt_list) <- sub(pattern = '.gmt.gz$', replacement = '', x = basename(gmt_files))
#### Convert to expected query format
t2e <- table2enr(deseq2.res.data = os_g_df, species = species, geneid.colname = 'Gene', geneid.type = 'SYMBOL', stat.colname = 'Score', topN.max = 0, p.colname = 'Adj.p', p.cutoff = adjp.max, stat.keep.operator = '>' )
for (bs in names(gmt_list)) {
  message(bs)
  ### GSEA
  suppressMessages(suppressWarnings(gsea_res <- gsea_run(geneList = t2e$gsea.genevec, func.name = 'clusterProfiler::GSEA', species = species, t2g = gmt_list[[bs]], t2g.name = bs, gene2Symbol = t2e$gene2Symbol, seed = my_seed, pvalueCutoff = adjp.max, minGSSize = enr_min_genes)))
  ## GSEA plots
  if(!is.null(gsea_res)) gsea_output(gseaResult = gsea_res, out.dir = gsurv.os_dir)
}


### PFS
gsurv.pfs_dir <- paste0(gsurv_dir, '/PFS')
dir.create(path = gsurv.pfs_dir, recursive = TRUE)
time_data <- de2.norm@colData$PFS_m
event_data <- as.numeric(de2.norm@colData$Progression) ## Check that progression positive ends as 2
pfs_g_res <- lapply(rownames(supervised_mat), function(myg) {
  ### Create temp df
  assoc_df <- data.frame(time = time_data, status = event_data, gexp = supervised_mat[myg,])
  ### Cox model
  surv_model <- survival::coxph(formula = survival::Surv(time = time, event = status) ~ gexp, data = assoc_df)
  ### Summary to get the p-value
  sm_smry <- summary(surv_model)
  return(c(surv_model$coefficients, surv_model$score, sm_smry$sctest[3]))
})
### Summarize in a df
pfs_g_df <- data.frame(Gene = rownames(supervised_mat), Reduce(f = rbind, x = pfs_g_res))
colnames(pfs_g_df) <- c('Gene', 'Coefficient', 'Score', 'Raw.p')
pfs_g_df$Adj.p <- p.adjust(p = pfs_g_df$Raw.p, method = 'BH')
pfs_g_df <- pfs_g_df[order(pfs_g_df$Score, decreasing = TRUE),]
### Output
WriteXLS::WriteXLS(x = pfs_g_df, ExcelFileName = paste0(gsurv.pfs_dir, '/Association_genes-x-PFS_coxph_results.xlsx'), SheetNames = 'PFS', AdjWidth = TRUE, AutoFilter = TRUE, BoldHeaderRow = TRUE, FreezeRow = 1, FreezeCol = 1, na = c(NA, 'NA', 'na', ''))
### GSEA/ORA
#### Convert to expected query format
t2e <- table2enr(deseq2.res.data = pfs_g_df, species = species, geneid.colname = 'Gene', geneid.type = 'SYMBOL', stat.colname = 'Score', topN.max = 0, p.colname = 'Adj.p', p.cutoff = adjp.max, stat.keep.operator = '>' )
for (bs in names(gmt_list)) {
  message(bs)
  ### GSEA
  suppressMessages(suppressWarnings(gsea_res <- gsea_run(geneList = t2e$gsea.genevec, func.name = 'clusterProfiler::GSEA', species = species, t2g = gmt_list[[bs]], t2g.name = bs, gene2Symbol = t2e$gene2Symbol, seed = my_seed, pvalueCutoff = adjp.max, minGSSize = enr_min_genes)))
  ## GSEA plots
  if(!is.null(gsea_res)) gsea_output(gseaResult = gsea_res, out.dir = gsurv.pfs_dir)
}


```

## Association with annotation

### Continuous variables

```{r surva_conti}
## Output dir
asurv.conti_dir <- paste(c(work_dir, 'Annotation-survival_association', 'Continuous'), collapse = '/')
dir.create(path = asurv.conti_dir, recursive = TRUE)

## Survival analysis

### OS
time_data <- de2.norm@colData$OS_m
event_data <- as.numeric(de2.norm@colData$OS_event) ## Check that death positive ends as 2
os_aconti_res <- lapply(qconti_vec, function(mya) {
  ### Create temp df
  assoc_df <- data.frame(time = time_data, status = event_data, annot = annot_df[[mya]])
  colnames(assoc_df)[3] <- mya
  ### Cox model
  my_f <- as.formula(paste0("survival::Surv(time = time, event = status) ~ ", mya))
  surv_model <- survival::coxph(formula = my_f, data = assoc_df)
  ### Summary to get the p-value
  sm_smry <- summary(surv_model)
  return(c(surv_model$coefficients, surv_model$score, sm_smry$sctest[3]))
})
### Summarize in a df
os_aconti_df <- data.frame(Annotation = qconti_vec, Reduce(f = rbind, x = os_aconti_res))
rm(os_aconti_res)
colnames(os_aconti_df) <- c('Annotation', 'Coefficient', 'Score', 'Raw.p')
os_aconti_df$Adj.p <- p.adjust(p = os_aconti_df$Raw.p, method = 'BH')
os_aconti_df <- os_aconti_df[order(os_aconti_df$Score, decreasing = TRUE),]
### Output
WriteXLS::WriteXLS(x = os_aconti_df, ExcelFileName = paste0(asurv.conti_dir, '/Association_annotation-x-OS_coxph_results.xlsx'), SheetNames = 'OS', AdjWidth = TRUE, AutoFilter = TRUE, BoldHeaderRow = TRUE, FreezeRow = 1, FreezeCol = 1)

### PFS
time_data <- de2.norm@colData$PFS_m
event_data <- as.numeric(de2.norm@colData$Progression) ## Check that progression positive ends as 2
pfs_aconti_res <- lapply(qconti_vec, function(mya) {
  ### Create temp df
  assoc_df <- data.frame(time = time_data, status = event_data, annot = annot_df[[mya]])
  colnames(assoc_df)[3] <- mya
  ### Cox model
  my_f <- as.formula(paste0("survival::Surv(time = time, event = status) ~ ", mya))
  surv_model <- survival::coxph(formula = my_f, data = assoc_df)
  ### Summary to get the p-value
  sm_smry <- summary(surv_model)
  return(c(surv_model$coefficients, surv_model$score, sm_smry$sctest[3]))
})
### Summarize in a df
pfs_aconti_df <- data.frame(Annotation = qconti_vec, Reduce(f = rbind, x = pfs_aconti_res))
rm(pfs_aconti_res)
colnames(pfs_aconti_df) <- c('Annotation', 'Coefficient', 'Score', 'Raw.p')
pfs_aconti_df$Adj.p <- p.adjust(p = pfs_aconti_df$Raw.p, method = 'BH')
pfs_aconti_df <- pfs_aconti_df[order(pfs_aconti_df$Score, decreasing = TRUE),]
### Output
WriteXLS::WriteXLS(x = pfs_aconti_df, ExcelFileName = paste0(asurv.conti_dir, '/Association_annotation-x-PFS_coxph_results.xlsx'), SheetNames = 'PFS', AdjWidth = TRUE, AutoFilter = TRUE, BoldHeaderRow = TRUE, FreezeRow = 1, FreezeCol = 1)

```

### Categorical variables

```{r surva_categ}
## Output dir
asurv.categ_dir <- paste(c(work_dir, 'Annotation-survival_association', 'Categorical'), collapse = '/')
dir.create(path = asurv.categ_dir, recursive = TRUE)

## Survival analysis

### OS
asurv.categ.os_dir <- paste0(asurv.categ_dir, '/OS/')
dir.create(path = asurv.categ.os_dir, recursive = TRUE)

time_data <- de2.norm@colData$OS_m
event_data <- as.numeric(de2.norm@colData$OS_event) ## Check that death positive ends as 2

for (mya in qcateg_vec) {
  ### Create temp df
  assoc_df <- data.frame(time = time_data, status = event_data, annot = as.factor(annot_df[[mya]]))
  colnames(assoc_df)[3] <- mya
  ### Survfit
  ggs_plot <- ggsurvfit::ggsurvfit(ggsurvfit::survfit2(formula = as.formula(paste0("survival::Surv(time = time, event = status) ~ ", mya)), data = assoc_df)) + ggsurvfit::add_confidence_interval() + ggsurvfit::add_risktable() + ggsurvfit::add_pvalue() + ggsurvfit::add_censor_mark() + ggsurvfit::add_legend_title(title = mya) + ggsurvfit::add_quantile()
  ### KM Plot
  svg(filename = paste0(asurv.categ.os_dir, '/Survival_', mya, '-x-OS_survfit_KM.svg'), width = 13, height = 9)
  print(ggs_plot)
  svg_off()
}

### PFS
asurv.categ.pfs_dir <- paste0(asurv.categ_dir, '/PFS/')
dir.create(path = asurv.categ.pfs_dir, recursive = TRUE)

time_data <- de2.norm@colData$PFS_m
event_data <- as.numeric(de2.norm@colData$Progression) ## Check that death positive ends as 2

for (mya in qcateg_vec) {
  ### Create temp df
  assoc_df <- data.frame(time = time_data, status = event_data, annot = as.factor(annot_df[[mya]]))
  colnames(assoc_df)[3] <- mya
  ### Survfit
  ggs_plot <- ggsurvfit::ggsurvfit(ggsurvfit::survfit2(formula = as.formula(paste0("survival::Surv(time = time, event = status) ~ ", mya)), data = assoc_df)) + ggsurvfit::add_confidence_interval() + ggsurvfit::add_risktable() + ggsurvfit::add_pvalue() + ggsurvfit::add_censor_mark() + ggsurvfit::add_legend_title(title = mya) + ggsurvfit::add_quantile()
  ### KM Plot
  svg(filename = paste0(asurv.categ.pfs_dir, '/Survival_', mya, '-x-PFS_survfit_KM.svg'), width = 13, height = 9)
  print(ggs_plot)
  svg_off()
}

#   
#   surv_model <- survival::coxph(formula = my_f, data = assoc_df)
#   ### Summary to get the p-value
#   sm_smry <- summary(surv_model)
#   return(c(surv_model$coefficients, surv_model$score, sm_smry$sctest[3]))
# })
# ### Summarize in a df
# os_aconti_df <- data.frame(Annotation = qconti_vec, Reduce(f = rbind, x = os_aconti_res))
# rm(os_aconti_res)
# colnames(os_aconti_df) <- c('Annotation', 'Coefficient', 'Score', 'Raw.p')
# os_aconti_df$Adj.p <- p.adjust(p = os_aconti_df$Raw.p, method = 'BH')
# os_aconti_df <- os_aconti_df[order(os_aconti_df$Score, decreasing = TRUE),]
# ### Output
# WriteXLS::WriteXLS(x = os_aconti_df, ExcelFileName = paste0(asurv.conti_dir, '/Association_annotation-x-OS_coxph_results.xlsx'), SheetNames = 'OS', AdjWidth = TRUE, AutoFilter = TRUE, BoldHeaderRow = TRUE, FreezeRow = 1, FreezeCol = 1)

### PFS
time_data <- de2.norm@colData$PFS_m
event_data <- as.numeric(de2.norm@colData$Progression) ## Check that progression positive ends as 2
pfs_aconti_res <- lapply(qconti_vec, function(mya) {
  ### Create temp df
  assoc_df <- data.frame(time = time_data, status = event_data, annot = annot_df[[mya]])
  colnames(assoc_df)[3] <- mya
  ### Cox model
  my_f <- as.formula(paste0("survival::Surv(time = time, event = status) ~ ", mya))
  surv_model <- survival::coxph(formula = my_f, data = assoc_df)
  ### Summary to get the p-value
  sm_smry <- summary(surv_model)
  return(c(surv_model$coefficients, surv_model$score, sm_smry$sctest[3]))
})
### Summarize in a df
pfs_aconti_df <- data.frame(Annotation = qconti_vec, Reduce(f = rbind, x = pfs_aconti_res))
rm(pfs_aconti_res)
colnames(pfs_aconti_df) <- c('Annotation', 'Coefficient', 'Score', 'Raw.p')
pfs_aconti_df$Adj.p <- p.adjust(p = pfs_aconti_df$Raw.p, method = 'BH')
pfs_aconti_df <- pfs_aconti_df[order(pfs_aconti_df$Score, decreasing = TRUE),]
### Output
WriteXLS::WriteXLS(x = pfs_aconti_df, ExcelFileName = paste0(asurv.conti_dir, '/Association_annotation-x-PFS_coxph_results.xlsx'), SheetNames = 'PFS', AdjWidth = TRUE, AutoFilter = TRUE, BoldHeaderRow = TRUE, FreezeRow = 1, FreezeCol = 1)

```

# Custom analyses

```{r custdir}
custom_dir <- paste0(work_dir, '/Custom_analyses')
```

## [Metastatic_lines] vs [Type_of_sample] (Fisher)

```{r custom1}
c1_dir <- paste0(custom_dir, '/Metastatic_lines_vs_Type_of_sample')
dir.create(path = c1_dir, recursive = TRUE)
chifisher(annot.table = annot_df, query.vec = c('Metastatic_line', 'Metastatic_CT_line', 'Metastatic_CT_line.3'), target.vec = 'Type_of_sample', test.type = 'F', out.dir = c1_dir)
```

## [Metastatic_CT_line.3] vs [Type_of_sample] (Fisher)

```{r custom1}
c1_dir <- paste0(custom_dir, '/Metastatic_CT_line.3_vs_Type_of_sample')
dir.create(path = c1_dir, recursive = TRUE)
chifisher(annot.table = annot_df, query.vec = 'Metastatic_CT_line.3', target.vec = 'Type_of_sample', test.type = 'F', out.dir = c1_dir)
```


# Rsession

```{r sessioninfo}

sessionInfo()

```

